<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Ambition-xwj.github.io</id>
    <title>Github pages</title>
    <updated>2020-04-11T09:51:52.280Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Ambition-xwj.github.io"/>
    <link rel="self" href="https://Ambition-xwj.github.io/atom.xml"/>
    <subtitle>徐文杰</subtitle>
    <logo>https://Ambition-xwj.github.io/images/avatar.png</logo>
    <icon>https://Ambition-xwj.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Github pages</rights>
    <entry>
        <title type="html"><![CDATA[Java并发编程之进程]]></title>
        <id>https://Ambition-xwj.github.io/post/java-bing-fa-bian-cheng-zhi-jin-cheng/</id>
        <link href="https://Ambition-xwj.github.io/post/java-bing-fa-bian-cheng-zhi-jin-cheng/">
        </link>
        <updated>2020-04-11T08:43:36.000Z</updated>
        <content type="html"><![CDATA[<p>Java并发编程（关于多线程概念的建立）</p>
<figure data-type="image" tabindex="1"><img src="https://Ambition-xwj.github.io/post-images/1586594887612.jpg" alt="" loading="lazy"></figure>
<p>1，什么是线程？</p>
<p>操作系统 ，进程，线程的包含关系</p>
<figure data-type="image" tabindex="2"><img src="https://Ambition-xwj.github.io/post-images/1586595646755.jpg" alt="" loading="lazy"></figure>
<p>注：thread表示的是线程。</p>
<p>即，1，概念：操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器<br>
2，Oracle文档的官方法定义：<br>
<img src="https://Ambition-xwj.github.io/post-images/1586596192650.jpg" alt="" loading="lazy"><br>
3，理解什么是进程 ？<br>
自己的理解：🙃当在电脑上下载一个和平精英的时候，如果不玩就不运行，只是一堆代码放置在那；如果玩和平精英，这个游戏就开始运行，会消耗文档，CPU，磁盘等，其都是以进程为单位的。<br>
<img src="https://Ambition-xwj.github.io/post-images/1586598179092.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式信息队列（MQ）]]></title>
        <id>https://Ambition-xwj.github.io/post/fen-bu-shi-xin-xi-dui-lie-mq/</id>
        <link href="https://Ambition-xwj.github.io/post/fen-bu-shi-xin-xi-dui-lie-mq/">
        </link>
        <updated>2020-04-06T06:53:23.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="分布式信息队列mq与技术选型">分布式信息队列（MQ）与技术选型</h2>
<p>分布式信息队列（MQ）应用场景:</p>
<p>1，服务解耦 <!--1，系统方面:如何解耦；2，业务层面：服务如何拆分与隔离；3，拆分与隔离如何通信；4，微服务是强依赖还是弱依赖-->可参考：</p>
<p>[http://zhuanlan.zhihu.com/p/31391535]:</p>
<p>2，削峰填谷   <!--主要针对于技术性高 流量性大的技术场景实现对应用服务的抗压--></p>
<p>注：实现对流量的高峰和低估做一个均衡。削峰：下由服务器处理不过来，把信息缓存到一个地方进行慢速消费；填谷：把开始的信息囤积到MQ中慢慢地消费。</p>
<p>3，异步化缓冲  <!--业务逻辑允许异步化的操作-->只需要做到一致性</p>
<p>🖌🖌🖌思考：</p>
<p>1，生产端可靠性投递</p>
<p>例如：金融不能把信息丢失？如何把信息发射出去与数据库保证原子性？</p>
<p>2，消费端幂等</p>
<p>对于重复的消息，消费端消费了两次或者多次导致数据不一致？</p>
<p>需要消息幂等不可消费多次进行信息幂等验证</p>
<p>3，高可用</p>
<p>若其中一个MQ挂机 磁盘不可用，怎样保证高可用？</p>
<p>4，底延迟  可靠性</p>
<p>对于流量大的冲压，如何保证信息的底延迟以及可靠性？</p>
<p>可靠性主流的kafua有分片以及副本的概念</p>
<p>5，堆积能力</p>
<p>对于信息堆积能力，如何预估信息在峰值期堆积的能力？在对于MQ技术选型的时候要衡量这种MQ能不能抗住峰值下的冲击，若抗不住就存在问题，怎么办？</p>
<p>6，扩展性</p>
<p>对于信息队列如何做到信息的延展性？</p>
<p>7,等等</p>
<p>的分布式信息队列(MQ)</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="分布式信息队列mq与技术选型">分布式信息队列（MQ）与技术选型</h2>
<p>分布式信息队列（MQ）应用场景:</p>
<p>1，服务解耦 <!--1，系统方面:如何解耦；2，业务层面：服务如何拆分与隔离；3，拆分与隔离如何通信；4，微服务是强依赖还是弱依赖-->可参考：</p>
<p>[http://zhuanlan.zhihu.com/p/31391535]:</p>
<p>2，削峰填谷   <!--主要针对于技术性高 流量性大的技术场景实现对应用服务的抗压--></p>
<p>注：实现对流量的高峰和低估做一个均衡。削峰：下由服务器处理不过来，把信息缓存到一个地方进行慢速消费；填谷：把开始的信息囤积到MQ中慢慢地消费。</p>
<p>3，异步化缓冲  <!--业务逻辑允许异步化的操作-->只需要做到一致性</p>
<p>🖌🖌🖌思考：</p>
<p>1，生产端可靠性投递</p>
<p>例如：金融不能把信息丢失？如何把信息发射出去与数据库保证原子性？</p>
<p>2，消费端幂等</p>
<p>对于重复的消息，消费端消费了两次或者多次导致数据不一致？</p>
<p>需要消息幂等不可消费多次进行信息幂等验证</p>
<p>3，高可用</p>
<p>若其中一个MQ挂机 磁盘不可用，怎样保证高可用？</p>
<p>4，底延迟  可靠性</p>
<p>对于流量大的冲压，如何保证信息的底延迟以及可靠性？</p>
<p>可靠性主流的kafua有分片以及副本的概念</p>
<p>5，堆积能力</p>
<p>对于信息堆积能力，如何预估信息在峰值期堆积的能力？在对于MQ技术选型的时候要衡量这种MQ能不能抗住峰值下的冲击，若抗不住就存在问题，怎么办？</p>
<p>6，扩展性</p>
<p>对于信息队列如何做到信息的延展性？</p>
<p>7,等等</p>
<p>的分布式信息队列(MQ)</p>
<!-- more -->
]]></content>
    </entry>
</feed>