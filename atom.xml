<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Ambition-xwj.github.io</id>
    <title>Github pages</title>
    <updated>2020-04-11T11:06:19.749Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Ambition-xwj.github.io"/>
    <link rel="self" href="https://Ambition-xwj.github.io/atom.xml"/>
    <subtitle>徐文杰</subtitle>
    <logo>https://Ambition-xwj.github.io/images/avatar.png</logo>
    <icon>https://Ambition-xwj.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Github pages</rights>
    <entry>
        <title type="html"><![CDATA[Java并发编程之线程]]></title>
        <id>https://Ambition-xwj.github.io/post/java-bing-fa-bian-cheng-zhi-xian-cheng/</id>
        <link href="https://Ambition-xwj.github.io/post/java-bing-fa-bian-cheng-zhi-xian-cheng/">
        </link>
        <updated>2020-04-11T10:58:07.000Z</updated>
        <content type="html"><![CDATA[<p>1，什么是线程？</p>
<p>用java编译器新建一 new package（background）一 类为Create100Threads 一 （目的：创建100个线程，用活动监视器的cpu栏目看Java线程数量的变化，10秒后线程消失）一 打开监测器</p>
<p>用java编译器编译</p>
<figure data-type="image" tabindex="1"><img src="https://Ambition-xwj.github.io/post-images/1586602911212.jpg" alt="" loading="lazy"></figure>
<p>打开编译器，首先我们可以看到进行线程的数量</p>
<figure data-type="image" tabindex="2"><img src="https://Ambition-xwj.github.io/post-images/1586602965814.jpg" alt="" loading="lazy"></figure>
<p>我们用代码启动编译器后，可以看看线程的数量</p>
<figure data-type="image" tabindex="3"><img src="https://Ambition-xwj.github.io/post-images/1586603053177.jpg" alt="" loading="lazy"></figure>
<p>我们可以打开系统管理器看看（左侧是进程，右侧是线程）</p>
<figure data-type="image" tabindex="4"><img src="https://Ambition-xwj.github.io/post-images/1586603094151.jpg" alt="" loading="lazy"></figure>
<p>进程和线程的不同：</p>
<p>1，起源不同（先有进程后有线程，后来由于处理器的速度往往比外设要快，外设就是键盘以及硬盘啊，处理器的速度远远要大于它们，为了提高cpu的利用率才诞生了线程，目的是提高程序的执行效率）2，概念不同（进程，是具有独立功能程序运行起来的一个活动，也是系统调动独立的单位，而线程是cpu调动的基本单位）3，内存共享方式不同（对于进程，不同的进程之间都会被操作系统分配一定的内存，但是不同进程之间的内存通常是不共享的，例如浏览器无法访问正在播放的QQ音乐，是没有办法直接访问内存，若要共享需要使用高级技巧为进程间通信ipc，but线程与线程之间是可以共享的，它们本身都服务于同一个进程，可以直接访问一定量的共享内存，不需要任何额外的处理）4，拥有的资源不同（线程是进程的一部分，则线程拥有的资源是比较少的，但有自己独有的一部分）5，数量不同（进程一个可以有千万个线程，但一个进程至少需要一个线程）6，开销不同</p>
<img src="C:\Users\徐文杰\Documents\sample\images\avatar\QQ图片20200411184912.jpg" style="zoom:50%;" />
<img src="C:\Users\徐文杰\Documents\sample\images\avatar\QQ图片20200411184943.jpg" style="zoom:50%;" />
<p>相似点：生命周期。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程之进程]]></title>
        <id>https://Ambition-xwj.github.io/post/java-bing-fa-bian-cheng-zhi-jin-cheng/</id>
        <link href="https://Ambition-xwj.github.io/post/java-bing-fa-bian-cheng-zhi-jin-cheng/">
        </link>
        <updated>2020-04-11T08:43:36.000Z</updated>
        <content type="html"><![CDATA[<p>Java并发编程（关于多线程概念的建立）</p>
<figure data-type="image" tabindex="1"><img src="https://Ambition-xwj.github.io/post-images/1586594887612.jpg" alt="" loading="lazy"></figure>
<p>1，什么是线程？</p>
<p>操作系统 ，进程，线程的包含关系</p>
<figure data-type="image" tabindex="2"><img src="https://Ambition-xwj.github.io/post-images/1586595646755.jpg" alt="" loading="lazy"></figure>
<p>注：thread表示的是线程。</p>
<p>即，1，概念：操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器<br>
2，Oracle文档的官方法定义：<br>
<img src="https://Ambition-xwj.github.io/post-images/1586596192650.jpg" alt="" loading="lazy"><br>
3，理解什么是进程 ？<br>
自己的理解：🙃当在电脑上下载一个和平精英的时候，如果不玩就不运行，只是一堆代码放置在那；如果玩和平精英，这个游戏就开始运行，会消耗文档，CPU，磁盘等，其都是以进程为单位的。<br>
<img src="https://Ambition-xwj.github.io/post-images/1586598179092.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式信息队列（MQ）]]></title>
        <id>https://Ambition-xwj.github.io/post/fen-bu-shi-xin-xi-dui-lie-mq/</id>
        <link href="https://Ambition-xwj.github.io/post/fen-bu-shi-xin-xi-dui-lie-mq/">
        </link>
        <updated>2020-04-06T06:53:23.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="分布式信息队列mq与技术选型">分布式信息队列（MQ）与技术选型</h2>
<p>分布式信息队列（MQ）应用场景:</p>
<p>1，服务解耦 <!--1，系统方面:如何解耦；2，业务层面：服务如何拆分与隔离；3，拆分与隔离如何通信；4，微服务是强依赖还是弱依赖-->可参考：</p>
<p>[http://zhuanlan.zhihu.com/p/31391535]:</p>
<p>2，削峰填谷   <!--主要针对于技术性高 流量性大的技术场景实现对应用服务的抗压--></p>
<p>注：实现对流量的高峰和低估做一个均衡。削峰：下由服务器处理不过来，把信息缓存到一个地方进行慢速消费；填谷：把开始的信息囤积到MQ中慢慢地消费。</p>
<p>3，异步化缓冲  <!--业务逻辑允许异步化的操作-->只需要做到一致性</p>
<p>🖌🖌🖌思考：</p>
<p>1，生产端可靠性投递</p>
<p>例如：金融不能把信息丢失？如何把信息发射出去与数据库保证原子性？</p>
<p>2，消费端幂等</p>
<p>对于重复的消息，消费端消费了两次或者多次导致数据不一致？</p>
<p>需要消息幂等不可消费多次进行信息幂等验证</p>
<p>3，高可用</p>
<p>若其中一个MQ挂机 磁盘不可用，怎样保证高可用？</p>
<p>4，底延迟  可靠性</p>
<p>对于流量大的冲压，如何保证信息的底延迟以及可靠性？</p>
<p>可靠性主流的kafua有分片以及副本的概念</p>
<p>5，堆积能力</p>
<p>对于信息堆积能力，如何预估信息在峰值期堆积的能力？在对于MQ技术选型的时候要衡量这种MQ能不能抗住峰值下的冲击，若抗不住就存在问题，怎么办？</p>
<p>6，扩展性</p>
<p>对于信息队列如何做到信息的延展性？</p>
<p>7,等等</p>
<p>的分布式信息队列(MQ)</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="分布式信息队列mq与技术选型">分布式信息队列（MQ）与技术选型</h2>
<p>分布式信息队列（MQ）应用场景:</p>
<p>1，服务解耦 <!--1，系统方面:如何解耦；2，业务层面：服务如何拆分与隔离；3，拆分与隔离如何通信；4，微服务是强依赖还是弱依赖-->可参考：</p>
<p>[http://zhuanlan.zhihu.com/p/31391535]:</p>
<p>2，削峰填谷   <!--主要针对于技术性高 流量性大的技术场景实现对应用服务的抗压--></p>
<p>注：实现对流量的高峰和低估做一个均衡。削峰：下由服务器处理不过来，把信息缓存到一个地方进行慢速消费；填谷：把开始的信息囤积到MQ中慢慢地消费。</p>
<p>3，异步化缓冲  <!--业务逻辑允许异步化的操作-->只需要做到一致性</p>
<p>🖌🖌🖌思考：</p>
<p>1，生产端可靠性投递</p>
<p>例如：金融不能把信息丢失？如何把信息发射出去与数据库保证原子性？</p>
<p>2，消费端幂等</p>
<p>对于重复的消息，消费端消费了两次或者多次导致数据不一致？</p>
<p>需要消息幂等不可消费多次进行信息幂等验证</p>
<p>3，高可用</p>
<p>若其中一个MQ挂机 磁盘不可用，怎样保证高可用？</p>
<p>4，底延迟  可靠性</p>
<p>对于流量大的冲压，如何保证信息的底延迟以及可靠性？</p>
<p>可靠性主流的kafua有分片以及副本的概念</p>
<p>5，堆积能力</p>
<p>对于信息堆积能力，如何预估信息在峰值期堆积的能力？在对于MQ技术选型的时候要衡量这种MQ能不能抗住峰值下的冲击，若抗不住就存在问题，怎么办？</p>
<p>6，扩展性</p>
<p>对于信息队列如何做到信息的延展性？</p>
<p>7,等等</p>
<p>的分布式信息队列(MQ)</p>
<!-- more -->
]]></content>
    </entry>
</feed>